# DB test

from typing import (
    Optional, Union, Any, Tuple, Dict, Set,
    Mapping, Sequence, Iterable, Iterator, Callable,
    Type, TypeVar, ClassVar,
    overload,
    NamedTuple,
    TYPE_CHECKING,
)
from typing_extensions import (
    Annotated, Protocol,
    dataclass_transform, get_origin, get_args, cast, get_type_hints,
    Self, Generic, TypeAlias, Literal,
)
import typing_extensions as tp
import sys
from types import MappingProxyType
from enum import Enum
from weakref import ref
import attrs
import attr
import dataclasses as dc
from itertools import zip_longest, chain
from contextlib import contextmanager
from sqlite3 import DatabaseError
from simpleeval import simple_eval
from .db import sqlite3_column_type, sql_dump, PrimaryKey, Db, DbCursor, SQL, update_db_version, Lock, db_manager, known_types_by_name
from ..types import is_optional, remove_optional, is_union_none, get_annotations, ReferenceType, TypeForm, AnnMeta, ann_type, find_arg_descr
from ..log_utils import fflog
from ..tricks import MISSING, is_namedtuple_class, namedtuple_attrs, singleton, dataclass_attrs, super_get_attr
from const import const
if TYPE_CHECKING:
    from pathlib import Path
    from attr import _ReprArgType, _OnSetAttrArgType, _ValidatorArgType, _ConverterType


def deep_get_attr(obj: object, key: str, *, safe: bool = False) -> Any:
    """Deep get attribute like super_get_attr() but separated with '::'."""
    if '::' not in key:
        return getattr(obj, key)
    for k in key.split('::'):
        if safe and obj is None:
            return None
        obj = getattr(obj, k)
    return obj


def quote(s: Optional[str]) -> str:
    """Return sql quoted item."""
    s = (s or '').replace('"', '\\"')
    return f'"{s}"'


RowData: TypeAlias = Union['DbTable', Mapping[str, Any]]
T = TypeVar('T')
V = TypeVar('V')
R = TypeVar('R')
TI = TypeVar('TI', bound='DbTable')
TABLE = TypeVar('TABLE', bound=Type['DbTable'])
# StatementType = TypeVar('StatementType', bound=Union[TABLE, Any])


class _FactoryProtocol:
    factory: Callable[..., Any]
    takes_self: bool


Factory = cast(Type[_FactoryProtocol], attr.Factory)

DbFieldDump: TypeAlias = Callable[..., Any]
DbFieldLoad: TypeAlias = Callable[..., Any]


@singleton
class SkipColumnType:
    """General type of singleton SKIP_COLUMN, this column should not be modified."""

    def __repr__(self) -> str:
        return 'SKIP_COLUMN'


@singleton
class AutoColumnType:
    """General type of singleton AUTO, this column is automaticly modfied."""

    def __repr__(self) -> str:
        return 'AUTO'


#: General skip column singleton object.
SKIP_COLUMN = SkipColumnType()

#: General auto column singleton object.
AUTO = AutoColumnType()


class AutoGenerated(Enum):
    """AutoGenerated mode, how to get column values."""
    NO = 'no'
    YES = 'yes'
    ONLY = 'only'
    IF_VALUES = 'if_values'


def is_dbtable(obj: Any) -> bool:
    """Return True if `obj` is DbTable class (not instance)."""
    return isinstance(obj, DbTableMeta) and issubclass(obj, DbTable)


@attrs.frozen
class AttrsFieldExtension:
    """Helper. DB table attrs field extra info (as attrs.Attribute metadata)."""
    METADATA: ClassVar[str] = '_FF_AttributeExtra'
    dump: Optional[DbFieldDump] = None
    load: Optional[DbFieldLoad] = None
    on_update: Any = MISSING
    auto_generated: bool = False
    foreign_key: Optional[str] = None


class DbField(NamedTuple):
    """Helper. DB table field info."""
    name: str
    column: str
    type: TypeForm[Any]
    optional: bool = False
    meta: Sequence[str] = ()
    default: Any = MISSING
    prefix: str = ''
    dump: Optional[DbFieldDump] = None
    load: Optional[DbFieldLoad] = None
    on_update: Any = MISSING
    auto_generated: bool = False
    foreign_key: Optional[str] = None
    fields: Optional[Mapping[str, 'DbField']] = None


# @with_function_typing(attr.field)
def field(*,  # type: ignore  ("xfield" is marked as overload, but no implementation is provided )
          default: Optional[T] = attrs.NOTHING,
          validator: Optional['_ValidatorArgType[T]'] = None,
          repr: '_ReprArgType' = True,
          hash: Optional[bool] = None,
          init: bool = True,
          metadata: Optional[Mapping[Any, Any]] = None,
          converter: Optional['_ConverterType'] = None,
          factory: Optional[Callable[[], T]] = None,
          kw_only: bool = False,
          eq: Optional[bool] = None,
          order: Optional[bool] = None,
          on_setattr: Optional['_OnSetAttrArgType'] = None,
          alias: Optional[str] = None,
          type: Optional[type] = None,
          # -- ORM extra --
          dump: Optional[DbFieldDump] = None,
          load: Optional[DbFieldLoad] = None,
          on_update: Any = MISSING,
          auto_generated: bool = False,
          foreign_key: Optional[str] = None,
          **kwargs):
    """Return an object to identify attrs fields. See attrs.field()."""
    if not TYPE_CHECKING:
        if default is attrs.NOTHING and on_update is not MISSING:
            default = MISSING  # type: ignore[reportAssignmentType]  -- use on_update() on INSERT too
    if metadata is None:
        meta = {}
    else:
        meta = dict(metadata)
    meta[AttrsFieldExtension.METADATA] = AttrsFieldExtension(dump=dump, load=load, on_update=on_update,
                                                             auto_generated=auto_generated)
    return attrs.field(default=default, validator=validator, repr=repr, hash=hash, init=init, metadata=meta,
                       type=type, converter=converter, factory=factory, kw_only=kw_only, eq=eq, order=order,
                       on_setattr=on_setattr, alias=alias, **kwargs)


class Relationship(Generic[TI, V]):
    """Relationship descriptor."""

    def __init__(self, *,
                 back_populates: Optional[str] = None,
                 on: Optional[str] = None,
                 when: Optional[str] = None,
                 ) -> None:
        self.name: str = ''
        self.ann: Optional[Type] = None
        self.is_table: bool = False
        self.back_populates: Optional[str] = back_populates
        self._on: Optional[str] = on
        self.when = when

    @property
    def on(self) -> str:
        if self._on is None:
            self._on = f'{self.name}_id'
        return self._on

    def __set_name__(self, objtype: Type[TI], name: str) -> None:
        ann = getattr(objtype, '__annotations__', {})
        self.name: str = name
        self.ann = ann.get(name)
        self.is_table = is_dbtable(self.ann)
        # if not self.on:
        #     iname = f'{name}_id'
        #     breakpoint()
        #     if (iann := ann.get(iname)) and (ival := getattr(objtype, iname, None)):# and isinstance(ival, attrs.Field):
        #         ...

    @overload
    def __get__(self, obj: None, objtype: Type[TI]) -> Self: ...

    @overload
    def __get__(self, obj: TI, objtype: None) -> V: ...

    def __get__(self, obj: Optional[TI], objtype: Optional[Type[TI]] = None) -> Any:
        if objtype is None:
            return self
        # d = dict(sys.modules[obj.__module__].__dict__)
        # exec(f'__Relationship_result__={self.ann}', globals(), d)
        # t = d['__Relationship_result__']
        if obj and (val := obj._rel_values.get(self.name, MISSING)) is not MISSING:
            return val
        if obj and (key := obj.__primary_index__) and (oid := getattr(obj, key, None)):
            with obj._db_cursor() as cur:
                if cur:
                    if isinstance(self.ann, str):
                        class X: pass
                        X.__annotations__ = {'x': self.ann}
                        try:
                            self.ann = get_annotations(X, globals=tp.__dict__, locals=sys.modules[obj.__class__.__module__].__dict__, eval_str=True)['x']
                        except Exception:
                            self.ann = None
                            fflog(f'Can not evaluate annotations for type {obj.__class__.__name__}')
                            return None
                    ann = None if self.ann is None else remove_optional(self.ann)
                    if isinstance(ann, type) and issubclass(ann, DbTable) and (fid := super_get_attr(obj, self.on, None)) is not None:
                        if self.when:
                            if simple_eval(self.when, names=lambda node: getattr(obj, node.id)):
                                return cur.get(ann, fid)
                            return None
                        return cur.get(ann, fid)
                    origin, args = get_origin(ann), get_args(ann)
                    if origin is Annotated:
                        origin, args = get_origin(args[0]), get_args(args[0])
                    # if is_union:
                    if isinstance(origin, type) and issubclass(origin, Sequence):
                        if not any(issubclass(origin, t) for t in (tuple, list, set)):
                            origin = tuple
                        typ = args[0]
                        if isinstance(typ, type) and issubclass(typ, DbTable) and self.back_populates:
                            # stmt = select(typ).where(getattr(typ, self.on) == oid)
                            stmt = select(typ).where(getattr(typ, f'{self.back_populates}_id') == oid)
                            val = origin(cur.exec(stmt).iter())
                            obj._rel_values[self.name] = val
                            return val
        return None

    def __set__(self, obj: TI, value: Any) -> None:
        raise RuntimeError()

    def __delete__(self, obj: TI, value: Any) -> None:
        raise RuntimeError()


def relationship(*,
                 init: Literal[False] = False,
                 back_populates: Optional[str] = None,
                 on: Optional[str] = None,
                 when: Optional[str] = None,
                 ) -> Any:
    return Relationship(back_populates=back_populates, on=on, when=when)


class ValueProperty:

    def __init__(self, field: DbField) -> None:
        self.field: DbField = field

    @overload
    def __get__(self, instance: None, objtype: TABLE) -> 'TableColumnExpr[TABLE]': ...

    @overload
    def __get__(self, instance: 'TI', objtype: Type['DbTable']) -> TI: ...

    def __get__(self, instance: Optional[TI], objtype: TABLE) -> Union[TI, 'TableColumnExpr[TABLE]']:
        # print(f'__get__({bool(instance)}, {objtype})  !!!!!!!!!!!!!!!!!')
        # if instance:
        #     return instance.__dict__[self.field.name]
        assert instance is None
        return TableColumnExpr(table=objtype, field=self.field)

    # def __set__(self, instance: str, value: Any) -> None:
    #     print(f'__set__(instance, {value=})  !!!!!!!!!!!!!!!!!')
    #     object.__setattr__(instance, self.field.name, value)
    #     # setattr(instance, self.field.name, value)
    #     # instance.__dict__[self.field.name] = value

    # def __set_name__(self, owner, name: str) -> None:
    #     print(f'__set_name__({owner=}, {name=}) !!!!!')


@dataclass_transform(kw_only_default=True, field_specifiers=(attr.attrib, attr.field, field, relationship, Relationship, DbField))
class DbTableMeta(type):

    def __new__(cls, name, bases: Tuple[Type[Any], ...], dct: Dict[str, Any], *, table: bool = True):
        table_name = dct.get('__tablename__', MISSING)
        if table_name is MISSING:
            table_name = dct['__tablename__'] = name.lower()
        if table and (not table_name or not isinstance(table_name, str)):
            raise TypeError(f'Missing __tablename__ in DbTable {name!r}')
        kls: Type[DbTable] = super().__new__(cls, name, bases, dct)
        # print(f' > meta.__new__({name=}, {bases=}, {dct=}): {kls=}')
        if '__attrs_attrs__' in dct:
            return kls  # already modfied by attrs (avoid recursion in slots class recreate)
        kls = attrs.define(kw_only=True, slots=False)(kls)
        # if table:
        #     for f in kls._fields.values():
        #         setattr(kls, f.name, ValueProperty(f))
        #         if 'PRIMARY KEY' in f.meta:
        #             kls.__primary_index__ = f.name
        #             kls.__skip_fileds__ = (*kls.__skip_fileds__, f.name)
        return kls

    @classmethod
    def _assing_fileds(cls):
        ...

    # def __setattr__(cls, name: str, value: Any) -> None:
    #     ...

    @property
    def _fields(self) -> Dict[str, DbField]:
        """Get fields."""
        def create_field(field: attr.Attribute, ann: Dict[str, TypeForm[Any]], *, optional: bool = False, prefix: str = '',
                         used: Set[TypeForm[Any]] = set(), default: Any = MISSING) -> DbField:
            typ: TypeForm[Any] = ann[field.name]
            optional = optional or is_optional(typ)
            fields = None
            typ, meta = ann_type(typ)
            if is_optional(typ):
                optional = True
                typ = remove_optional(typ)

            if isinstance(field.default, Factory):
                default = field.default.factory()
            elif field.default is not attrs.NOTHING and field.default is not dc.MISSING:
                default = field.default
            # elif isinstance(field, DcFieldExtension) and field.on_update is not MISSING:
            #     default = field.on_update
            if default is attrs.NOTHING or default is dc.MISSING:
                default = MISSING
            elif default is AUTO:
                if optional:
                    default = None
                else:
                    default = MISSING

            metadata: Optional[AttrsFieldExtension] = (field.metadata or {}).get(AttrsFieldExtension.METADATA)
            if metadata:
                kwargs = {
                    'dump': metadata.dump,
                    'load': metadata.load,
                    'on_update': metadata.on_update,
                    'auto_generated': metadata.auto_generated,
                }
            else:
                kwargs = {}

            if attrs.has(type) or dc.is_dataclass(typ) or is_namedtuple_class(typ):
                if typ in used:
                    raise TypeError(f'DB Table type recursion {self.__name__}.{prefix}{field.name}: {typ.__name__}')
                used.add(typ)
                pre = f'{prefix}{field.name}::'
                sub_ann = get_type_hints(typ, include_extras=True)
                if attrs.has(typ):
                    sub_fields = attrs.fields(typ)
                elif is_namedtuple_class(typ):
                    sub_fields = namedtuple_attrs(typ)
                elif dc.is_dataclass(typ):
                    sub_fields = dataclass_attrs(typ)
                else:
                    sub_fields = ()
                if default is MISSING or default is attrs.NOTHING:
                    sub_def = ()
                elif optional and default is None:
                    sub_def = ()
                else:
                    if not isinstance(default, ann[field.name]):
                        raise TypeError(f'DB Table type of default mismatch {self.__name__}.{prefix}{field.name}: {typ.__name__} is not ({type(default)}')
                    sub_def = tuple(getattr(default, f.name) for f in sub_fields if not f.name.startswith('_'))
                assert len(sub_fields) >= len(sub_def)
                fields = {f.name: create_field(f, sub_ann, optional=optional, prefix=pre, default=d)
                          for f, d in zip_longest(sub_fields, sub_def, fillvalue=default)}  # `sub_fields` could NOT be shorter then `sub_def`
                used.remove(typ)

            return DbField(name=field.name, column=f'{prefix}{field.name}', type=typ, optional=optional, meta=meta, default=default,
                           prefix=prefix, fields=fields, **kwargs)

        tab = cast(Type[DbTable], self)
        if tab._fields_info is None:
            try:
                ann = get_type_hints(self, include_extras=True)
            except Exception:
                ann = get_type_hints(self, {**tp.__dict__, **globals()}, sys.modules[tab.__module__].__dict__, include_extras=True)
            if attrs.has(self):
                fields = attrs.fields(self)
            elif is_namedtuple_class(self):
                fields = namedtuple_attrs(self)
            elif dc.is_dataclass(self):
                fields = dataclass_attrs(self)
            else:
                fields = ()
            tab._fields_info = {f.name: create_field(f, ann) for f in fields if not f.name.startswith('_')}
            # ???
            for f in tab._fields_info.values():
                setattr(self, f.name, ValueProperty(f))
                if 'PRIMARY KEY' in f.meta:
                    tab.__primary_index__ = f.name
                    tab.__skip_fileds__ = (*tab.__skip_fileds__, f.name)
        return tab._fields_info


class DbTable(metaclass=DbTableMeta, table=False):

    __tablename__: ClassVar[str] = ''
    __skip_fileds__: ClassVar[Sequence[str]] = ()
    __primary_index__: ClassVar[Optional[str]] = None
    # --- private fields ---
    _fields_info: ClassVar[Optional[Dict[str, DbField]]] = None
    _db: 'Union[Db, OrmDatabase, None]' = attrs.field(init=False, repr=False, default=None)
    _db_cur: Optional[ReferenceType[DbCursor]] = attrs.field(init=False, repr=False, default=None)
    _db_values: Dict[str, Any] = attrs.field(init=False, repr=False, factory=dict)
    _rel_values: Dict[str, Any] = attrs.field(init=False, repr=False, factory=dict)

    def __new__(cls, **kwargs) -> Self:
        """Create object."""
        obj = super().__new__(cls)
        obj._db = None
        obj._db_cur = None
        obj._db_values = {}
        return obj

    def model_dump(self, *, exclude: Optional[Iterable[str]] = None) -> Mapping[str, Any]:
        """Dump data as dict (values)."""
        exclude = set(exclude or ())
        return {k: getattr(self, k) for k in self._fields_info or () if k not in exclude}

    def model_serialize(self, *, exclude: Optional[Iterable[str]] = None) -> Mapping[str, Any]:
        """Dump data as dict (serialization)."""

        def dump(obj: object, fields: Iterable[DbField], *, exclude: Optional[Iterable]) -> Iterator[Tuple[str, Any]]:
            for field in fields:
                if exclude and field.name in exclude:
                    continue
                if field.dump is not None:
                    yield field.name, field.dump(self)
                elif field.fields is None:
                    yield field.name, getattr(obj, field.name)
                else:
                    subobj = getattr(obj, field.name)
                    if subobj is None:
                        yield field.name, None
                    else:
                        yield field.name, dict(dump(getattr(obj, field.name), field.fields.values(), exclude=None))

        if exclude:
            exclude = set(exclude)
        return dict(dump(self, self.__class__._fields.values(), exclude=exclude))

    def _update_db(self, db: 'Union[Db, OrmDatabase, None]', cur: Optional[DbCursor]) -> None:
        """Update current DB reference."""
        if self._db is None:
            self._db = db
            if cur is not None:
                self._db_cur = ref(cur)

    @contextmanager
    def _db_cursor(self) -> Iterator[Optional[DbCursor]]:
        """Statement with DB cursor (if avaliable)."""
        cur: Optional[DbCursor] = None if self._db_cur is None else self._db_cur()
        if cur is not None and not cur.closed:
            # current opened cursor, we should NOT close it
            yield cur
        elif self._db is not None:
            # no cursor but we have DB, create new cursor
            with self._db.cursor() as cur:
                yield cur
        else:
            # no DB
            yield None

    @classmethod
    def _create_columns_query(cls) -> str:
        """Return sqlite3 create table columns part of query."""

        def get_col(field: DbField, *, optional: bool = False) -> Iterator[Tuple[str, str]]:
            if field.fields is None:
                constraints = []
                if isinstance(field.type, str):  # impossible at this moment, get_type_hints() raises NameError()
                    constraints.append(field.type)
                else:
                    constraints.append(sqlite3_column_type.get(field.type, 'TEXT'))
                for meta in field.meta:
                    if isinstance(meta, str):
                        constraints.append(meta)
                optional = optional or field.optional
                if not optional and 'NOT NULL' not in constraints:
                    constraints.append('NOT NULL')
                if field.default is attrs.NOTHING:
                    if const.debug.tty:
                        import sty
                        fflog(f'{sty.bg.red}ERROR:{sty.rs.all} NOTHING as default in {cls.__name__}.{field.name}: {field}')
                    else:
                        fflog(f'ERROR: NOTHING as default in {cls.__name__}.{field.name}: {field}')
                elif field.default is not MISSING:
                    constraints.append(f'DEFAULT {sql_dump(field.default)}')
                yield field.column, ' '.join(constraints)
            else:
                for sub in field.fields.values():
                    yield from get_col(sub, optional=optional)

        query = ', '.join((f'{quote(name)} {ftype}') for f in cls._fields.values() for name, ftype in get_col(f))
        return query

    @classmethod
    def _create_table_query(cls, *, if_not_exists: bool = True) -> str:
        """Return sqlite3 create table query."""
        tab_def = [cls._create_columns_query()]
        tab_args = getattr(cls, '__table_args__', None)
        if tab_args:
            for arg in tab_args:
                if isinstance(arg, str):
                    tab_def.append(arg)
        todo = ['CREATE TABLE']
        if if_not_exists:
            todo.append('IF NOT EXISTS')
        cmd = ' '.join(todo)
        return f'{cmd} {quote(cls.__tablename__)} ({", ".join(tab_def)})'

    @classmethod
    def _column_fields(cls, *, primary_index: bool = True, column: Optional[str] = None, updates: bool = True) -> Mapping[str, DbField]:
        """Return sqlite3 column for query."""
        def get(field: DbField) -> Iterator[Tuple[str, DbField]]:
            if updates or field.on_update is MISSING:
                if field.fields is None:
                    yield field.column, field
                else:
                    for sub in field.fields.values():
                        yield from get(sub)

        fields = cls._fields.values()
        if column:
            return {c: g for f in fields if f.name == column for c, g in get(f)}
        if primary_index or not cls.__primary_index__:
            forbidden = ''
        else:
            forbidden = cls.__primary_index__
        return {c: g for f in fields if f.name != forbidden for c, g in get(f)}

    @classmethod
    def _from_row(cls, row: Mapping[str, Any]) -> Self:
        """Create new object from row dict (with subobject keys too)."""

        def new(fields: Mapping[str, DbField], data: Mapping[str, Any]) -> Iterator[Tuple[str, object]]:
            ddata: Optional[Mapping[str, Any]] = None
            for name, f in fields.items():
                if name.startswith('_'):
                    continue
                if ddata is None:
                    if f.prefix:
                        p = len(f.prefix)
                        ddata = {k[p:]: v for k, v in data.items() if k.startswith(f.prefix)}
                    else:
                        ddata = data
                if f.fields:
                    p = f'{f.prefix}::{name}'
                    values = dict(new(f.fields, ddata))
                    if f.optional and all(v is None for v in values.values()):
                        yield name, None
                    else:
                        try:
                            yield name, f.type(**values)
                        except Exception:
                            fflog(f'>>>>> {f.type=}, {data=}, {ddata=}, {values=}')
                            raise
                elif (value := ddata.get(name, MISSING)) is not MISSING:
                    if value is not None:
                        try:
                            pure_type = f.type if isinstance(f.type, type) else None
                            at, meta = find_arg_descr(f.type, meta=f.meta, quiet=True)
                            if at is not None:
                                value = at.load(str(value), f.type, meta)
                            elif pure_type and (conv := known_types_by_name.get(pure_type.__name__)):
                                value = conv(value)
                            elif pure_type and issubclass(pure_type, Enum):
                                if isinstance(value, str) and value.isdecimal():
                                    value = pure_type(int(value))
                                else:
                                    value = pure_type(value)
                            elif pure_type:
                                value = pure_type(value)
                        except Exception:
                            pass
                    yield name, value

        # if all('::' not in k for k in row):  # can NOT optymalize, we need conversion
        #     return cls(**row)
        obj = cls(**dict(new(cls._fields_info or {}, row)))
        obj._db_values = row  # type: ignore -- `_db_values` is hidden instance attribute
        return obj

    @classmethod
    def _select(cls) -> 'Statement':  # TODO: remove?
        """Execute sqlite3 select query."""
        return Statement(cls, statement='SELECT')

    @classmethod
    def _get(cls, cur: DbCursor, id: int) -> Optional[Self]:
        """Return query for get()."""
        if not cls.__primary_index__:
            return None
        stmt = Statement(cls).where(Expr(value=f'{quote(cls.__primary_index__)} = {sql_dump(id)}'))
        result = cur.exec(stmt)
        return result.first()

    def _asdict(self, *, columns: Optional[Iterable[str]] = None, primary_index: bool = True) -> Dict[str, Any]:
        if columns is None:
            primary = self.__primary_index__
            return {f.name: getattr(self, f.name)
                    for f in attrs.fields(self.__class__) if primary_index or f.name != primary}
        else:
            return {name: getattr(self, name) for name in columns}

    def _column_values(self, *, primary_index: bool = True, column: Optional[str] = None, updates: bool = True,
                       auto_generated: AutoGenerated = AutoGenerated.YES) -> Dict[str, Any]:
        def dump(val: Any, field: DbField) -> Any:
            if isinstance(val, Enum):
                at, meta = find_arg_descr(field.type, meta=field.meta)
                if at is not None:
                    return at.dump(val, field.type, meta)
                return val.value
            return val

        columns = self._column_fields(primary_index=False)
        values: Dict[str, Tuple[Any, DbField]] = {}
        if auto_generated in (AutoGenerated.NO, AutoGenerated.YES, AutoGenerated.IF_VALUES):
            values.update((f.column, (v, f)) for f in columns.values()
                          if not f.auto_generated and (v := self._get_value(f)) is not MISSING and v is not SKIP_COLUMN and v != self._db_values.get(f.column, MISSING))
        if auto_generated in (AutoGenerated.YES, AutoGenerated.ONLY) or (auto_generated is AutoGenerated.IF_VALUES and values):
            values.update((f.column, (v, f)) for f in columns.values() if f.auto_generated and (v := self._get_value(f)) is not MISSING and v is not SKIP_COLUMN)
        return {k: dump(v, f) for k, (v, f) in values.items()}

    def _set_row_id(self, id: int) -> None:
        if self.__primary_index__:
            name: str = self.__primary_index__
            if getattr(self, name) is None:
                setattr(self, name, id)

    def _has_primary_index(self) -> bool:
        """Return True if primary index is set."""
        return bool(self.__primary_index__ and getattr(self, self.__primary_index__) is not None)

    def _get_value(self, field: DbField) -> Any:
        """Get single column value from given field."""
        if field.on_update is MISSING:
            return deep_get_attr(self, field.column, safe=True)
        if field.on_update is SKIP_COLUMN:
            return MISSING
        if callable(field.on_update):
            return field.on_update(deep_get_attr(self, field.column, safe=True))
        # if isinstance(field.on_update, sql):
        #     return MISSING
        return field.on_update

    def _insert(self, cur: DbCursor) -> bool:
        """Execute INSERT query."""
        # values = self._column_values(primary_index=False, auto_generated=AutoGenerated.NO)
        # auto_values = self._column_values(primary_index=False, auto_generated=AutoGenerated.ONLY)
        # names = ', '.join(quote(a) for a in chain(values, auto_values))
        # refs = ', '.join(f':{a}' for a in values)
        # if auto_values:
        #     refs = ', '.join((refs, ', '.join(sql_dump(v) for v in auto_values.values())))
        # query = f'INSERT INTO {quote(self.__tablename__)} ({names}) VALUES ({refs})'
        query, values = self._prepare_insert()
        cur.execute(query, values)
        self._set_row_id(cur.lastrowid)
        self._db_values = values  # type: ignore -- `_db_values` is hidden instance attribute
        return True

    def _prepare_insert(self) -> Tuple[str, Mapping[str, Any]]:
        """Prepare data for INSERT many objects."""
        values = self._column_values(primary_index=False, auto_generated=AutoGenerated.NO)
        auto_values = self._column_values(primary_index=False, auto_generated=AutoGenerated.ONLY)
        names = ', '.join(quote(a) for a in chain(values, auto_values))
        refs = ', '.join(f':{a}' for a in values)
        if auto_values:
            refs = ', '.join((refs, ', '.join(sql_dump(v) for v in auto_values.values())))
        query = f'INSERT INTO {quote(self.__tablename__)} ({names}) VALUES ({refs})'
        return query, values

    # @classmethod
    # def _insert_many(cls, cur: DbCursor, query: str, values: Iterable[Mapping[str, Any]]) -> bool:
    #     """Execute INSERT query on many objects."""
    #     cur.execute(query, values)
    #     return True

    def _update(self, cur: DbCursor) -> bool:
        """Execute UPDATE query."""
        if self.__primary_index__:
            index = self.__primary_index__
            values = self._column_values(primary_index=False, auto_generated=AutoGenerated.NO)
            auto_values = self._column_values(primary_index=False, auto_generated=AutoGenerated.ONLY)
            if values and index:
                names = ', '.join(f'{quote(a)}=:{a}' for a in values)
                if auto_values:
                    names = ', '.join((names, ', '.join(f'{quote(a)}={sql_dump(v)}' for a, v in auto_values.items())))
                values[index] = deep_get_attr(self, index)
                query = f'UPDATE {quote(self.__tablename__)} SET {names} WHERE {quote(index)} = :{index}'
                cur.execute(query, values)
                return True
        return False


class Expr:
    """Simple SQL WHERE statement condition."""

    _reverse_ops = {
        '=': '!=',
        '!=': '=',
        '<': '>=',
        '<=': '>',
        '>': '<=',
        '>=': '<',
        'IS': 'IS NOT',
        'IS NOT': 'IS',
        'IN': 'NOT IN',
        'NOT IN': 'IN',
    }

    def __init__(self, scalar: Any = MISSING, *, op: str = '', value: str = '', second: str = '') -> None:
        self.op: str = op
        self.value: str = value if scalar is MISSING else sql_dump(scalar)
        self.second: str = second

    def __repr__(self) -> str:
        return f'Expr(op={self.op!r}, value={self.value!r}, second={self.second!r})'

    def __str__(self) -> str:
        if self.second:
            return f'{self.value} {self.op} {self.second}'
        if self.op:
            return f'{self.op} {self.value}'
        return str(self.value)

    def __eq__(self, other: Any) -> 'Expr':
        if other is None:
            return Expr(value=str(self), op='IS', second='NULL')
        return Expr(value=str(self), op='=', second=sql_dump(other))

    def __ne__(self, other: Any) -> 'Expr':
        if other is None:
            return Expr(value=str(self), op='IS NOT', second='NULL')
        return Expr(value=str(self), op='!=', second=sql_dump(other))

    def __lt__(self, other: Any) -> 'Expr':
        return Expr(value=str(self), op='<', second=sql_dump(other))

    def __le__(self, other: Any) -> 'Expr':
        return Expr(value=str(self), op='<=', second=sql_dump(other))

    def __gt__(self, other: Any) -> 'Expr':
        return Expr(value=str(self), op='>', second=sql_dump(other))

    def __ge__(self, other: Any) -> 'Expr':
        return Expr(value=str(self), op='>=', second=sql_dump(other))

    # TODO: add more operators, like +, -, *, ...

    def __invert__(self):
        return NOT(self)

    def __and__(self, other: Any) -> 'Expr':
        return AND(self, other)

    def __or__(self, other: Any) -> 'Expr':
        return OR(self, other)

    def __matmul__(self, other: Union[Iterable[Any], 'Statement']) -> 'Expr':
        return IN(self, other)


class TableColumnExpr(Expr, Generic[TABLE]):
    """Simple start of SQL WHERE statement (only table column)."""

    def __init__(self, *, table: TABLE, field: DbField) -> None:
        self.table: Type[DbTable] = table
        self.field: DbField = field
        if field.fields is None:
            super().__init__(value=f'{quote(self.table.__tablename__)}.{quote(self.field.column)}')
        else:
            values = ', '.join(f'{quote(self.table.__tablename__)}.{quote(column)}' for column in table._column_fields(column=field.name))
            super().__init__(value=f'({values})')

    def __hash__(self) -> int:
        return hash(id(self.table)) ^ hash(self.field)

    def __getattr__(self, name: str) -> 'TableColumnExpr':
        """Return sub-object column."""
        fields = self.field.fields
        if fields is not None and name in fields:
            return TableColumnExpr(table=self.table, field=fields[name])
        raise AttributeError(name)


def AND(where: Any, *others: Any) -> Expr:
    return Expr(value=' AND '.join(f'({sql_dump(e)})' for e in (where, *others)))


def OR(where: Any, *others: Any) -> Expr:
    return Expr(value=' OR '.join(f'({sql_dump(e)})' for e in (where, *others)))


def NOT(value: Any) -> Expr:
    if isinstance(value, Expr):
        op = Expr._reverse_ops.get(value.op)
        if op:
            return Expr(op=op, value=value.value, second=value.second)
        val = value
    else:
        val = sql_dump(value)
    return Expr(op='NOT', value=f'({val})')


@overload
def IN(where: Expr, values: Union[Iterable[Any], 'Statement']) -> Expr: ...


@overload
def IN(where: Iterable[TableColumnExpr], values: Iterable[Sequence[Any]]) -> Expr: ...


@overload
def IN(where: Any, values: Iterable[Any]) -> Expr: ...


def IN(where: Union[Expr, Iterable[TableColumnExpr]], values: Union[Iterable[Any], 'Statement']) -> Expr:
    if isinstance(values, Statement):
        values = [values]
    if isinstance(where, Expr):
        vals = ', '.join(map(sql_dump, values))
        return Expr(value=str(where), op='IN', second=f'({vals})')
    else:
        cols = ', '.join(map(str, where))
        vals = ', '.join(f'({", ".join(map(sql_dump, row))})' for row in values)
        return Expr(value=f'({cols})', op='IN', second=f'(VALUES {vals})')


def IS(where: Any, other: Any) -> Expr:
    return Expr(value=sql_dump(where), op='IS', second=sql_dump(other))


class Statement(Generic[R]):
    """Select class to operate on SELECT and so on."""

    @overload
    def __init__(self, *tables: Type[DbTable], statement: Optional[str] = None) -> None: ...

    @overload
    def __init__(self, table: TableColumnExpr, *, statement: Optional[Literal['SELECT']] = None) -> None: ...

    @overload
    def __init__(self, table: Any, *, statement: Optional[Literal['SELECT']] = None) -> None: ...

    def __init__(self, *tables: Union[Type[DbTable], Any], statement: Optional[str] = None) -> None:
        self._tables = tuple(tables)
        self._where: Optional[Expr] = None
        self._order: Optional[str] = None
        self._statement: str = statement or 'SELECT'
        self._columns: Mapping[str, DbField] = {}
        # self._data: Union[None, RowData, Iterable[RowData]] = None
        self._data: Sequence[RowData] = []

    def __str__(self) -> str:
        return self.get()

    def where(self, where: Union[Expr, Any]) -> Self:
        if self._where is None:
            self._where = where
        else:
            self._where = AND(self._where, where)
        return self

    def order_by(self, order: str) -> Self:  # XXX: TODO: add statement not str !!! XXX
        self._order = order
        return self

    def join(self):
        ...

    def _where_query(self) -> str:
        if self._where:
            return f' WHERE {self._where}'
        else:
            return ''

    def _order_query(self) -> str:
        if self._order:
            return f' ORDER BY {self._order}'
        else:
            return ''

    def _select(self) -> str:
        def get_tab(val: Any) -> Iterator[str]:
            if is_dbtable(val):
                yield quote(val.__tablename__)
            elif isinstance(val, TableColumnExpr):
                yield quote(val.table.__tablename__)

        def get_col(val: Any, *, i: int) -> Iterator[str]:
            if is_dbtable(val):
                tab: Type[DbTable] = val
                for col in tab._column_fields(primary_index=True):
                    yield f'{quote(tab.__tablename__)}.{quote(col)} AS "{tab.__tablename__}.{col}"'
            elif isinstance(val, TableColumnExpr):
                tab: Type[DbTable] = val.table
                for col in tab._column_fields(primary_index=False, column=val.field.name):
                    yield f'{quote(tab.__tablename__)}.{quote(col)} AS "{tab.__tablename__}.{col}"'
            else:
                yield f'{sql_dump(val)} AS out_{i}'

        tables = ', '.join(f for t in self._tables for f in get_tab(t))
        if tables:
            tables = f' FROM {tables}'
        cols = ', '.join(c for i, t in enumerate(self._tables, 1) for c in get_col(t, i=i))
        return f'{self._statement} {cols}{tables}{self._where_query()}{self._order_query()}'

    def _insert(self) -> str:
        if len(self._tables) != 1:
            raise ValueError(f'Can NOT insert to many tables ({len(self._tables)})')
        tab = self._tables[0]
        self._columns = tab._column_fields(primary_index=False, updates=False)
        cols = ', '.join(map(quote, self._columns))
        vals = ', '.join('?' for _ in self._columns)
        return f'{self._statement} INTO {quote(tab.__tablename__)} ({cols}) VALUES ({vals})'

    def _update(self) -> str:
        if len(self._tables) != 1:
            raise ValueError(f'Can NOT update many tables ({len(self._tables)})')
        tab = self._tables[0]
        if not self._data:
            raise ValueError(f'Can NOT update unknown data for {tab.__class__.__name__}')
        tab_data = self._data[0]
        if isinstance(tab_data, DbTable):
            if type(tab_data) is not tab:
                raise ValueError(f'Data ({self._data.__class__.__name__} does NOT match to table {tab.__class__.__name__}')
            data = tab_data._asdict()
        else:
            data = tab_data

        self._columns = attrs = {c: f for c, f in tab._column_fields(primary_index=False).items() if c in data}
        names = ', '.join(f'{quote(a)}=:{a}' for a in attrs)
        return f'{self._statement} {quote(tab.__tablename__)} SET {names}{self._where_query()}'

    def _delete(self) -> str:
        if len(self._tables) != 1:
            raise ValueError(f'Can NOT delete from many tables ({len(self._tables)})')
        tab = self._tables[0]
        return f'{self._statement} FROM {quote(tab.__tablename__)}{self._where_query()}'

    def get(self) -> str:
        if self._statement == 'SELECT':
            return self._select()
        if self._statement in ('INSERT', 'INSERT OR IGNORE', 'INSERT OR REPLACE'):
            return self._insert()
        if self._statement in ('UPDATE', 'UPDATE OR IGNORE'):
            return self._update()
        if self._statement in ('DELETE',):
            return self._delete()
        return ''

    def set(self, **values: Any) -> Self:
        unknown = set(self._columns) - values.keys()
        if unknown:
            vv = ', '.join(unknown)
            raise TypeError(f'Unmatched arguments: {vv}')
        self._data = [values]
        return self

    def exec(self, cur: DbCursor, data: Union[None, RowData, Iterable[RowData]] = None) -> 'Result[R]':
        def asdict(d: RowData) -> Mapping[str, Any]:
            if isinstance(d, DbTable):
                d._update_db(cur.db, cur)
                return d._asdict(columns=self._columns)
            return d

        if data is None and self._data is not None:
            data = self._data

        try:
            if not data:
                cur.execute(self.get())
            elif isinstance(data, (DbTable, Mapping)):
                cur.execute(self.get(), asdict(data))
            else:
                cur.executemany(self.get(), (asdict(obj) for obj in data))
        except DatabaseError as exc:
            fflog(f'DB ERROR ({exc}) on {self.get()!r}')
            raise
        return Result(cursor=cur, statement=self)


@attrs.define(kw_only=True)
class Result(Generic[T]):

    cursor: DbCursor
    statement: Statement

    def new(self, tab: Type[DbTable], row: Mapping[str, Any], *, single: bool = False, i: int = 1) -> Any:
        if is_dbtable(tab):
            if single:
                prefix = f'{tab.__tablename__}.'  # ''
            else:
                prefix = f'{tab.__tablename__}.'
            instance = tab._from_row({k[len(prefix):]: v for k, v in row.items() if k.startswith(prefix)})
            instance._update_db(self.cursor.db, self.cursor)
            return instance
        if isinstance(tab, TableColumnExpr):
            prefix = f'{tab.table.__tablename__}.'
            return row[f'{prefix}{tab.field.name}']
        return row[f'out_{i}']

    def __iter__(self) -> Iterator[T]:
        return iter(self.iter())

    def iter(self) -> Iterator[T]:
        if len(self.statement._tables) == 1:
            tab = self.statement._tables[0]
            for row in self.cursor:
                yield self.new(tab, row, single=True)
        else:
            for row in self.cursor:
                yield tuple(self.new(tab, row, i=i) for i, tab in enumerate(self.statement._tables, 1))

    def all(self) -> Sequence[T]:
        return list(self.iter())

    def first(self) -> Union[None, T]:
        for result in self.iter():
            return result
        return None

    def one(self) -> T:
        it = iter(self)
        try:
            result = next(it)
        except StopIteration:
            raise KeyError('No row was found when one was required') from None
        try:
            result = next(it)  # second
        except StopIteration:
            return result
        raise KeyError('Multiple rows were found when exactly one was required')


@overload
def select(table: Type[TI], /) -> Statement[TI]: ...


@overload
def select(table: TableColumnExpr[Type[TI]], /) -> Statement[TI]: ...


@overload
def select(tab1: Type[DbTable], tab2: Type[DbTable], /, *tables: Type[DbTable]) -> Statement[Tuple[DbTable, ...]]: ...


@overload
def select(*tables: Any) -> Statement[Any]: ...


def select(*tables: Union[Type[DbTable], Any]) -> Statement:
    return Statement(*tables)


def update(table: Type[DbTable]) -> Statement:
    return Statement(table, statement='UPDATE')


def update_or_ignore(table: Type[DbTable]) -> Statement:
    return Statement(table, statement='UPDATE OR IGNORE')


def delete(table: Type[DbTable]) -> Statement:
    return Statement(table, statement='DELETE')


def dump_fields(kls: Type[DbTable]) -> str:
    """Dump DbTable files to string."""
    def dump(fields: Iterable[DbField], lvl: int) -> Iterator[str]:
        indent = '    ' * lvl or ' '
        for i, f in enumerate(fields):
            sep = f'\n{indent}' if i else f'\n{indent}' if lvl else '{'
            vv = ', '.join(f'{k}={getattr(f, k)!r}' for k in ff if k != 'fields')
            yield f'{sep}{f.name!r}: DbFieldInfo({vv}, fields='
            if f.fields:
                yield from dump(f.fields.values(), lvl + 1)
            else:
                yield repr(f.fields)
            yield ')'
        yield '}'

    ff = DbField._fields
    return ''.join(dump(kls._fields.values(), 0))


class OrmDatabase:
    """Simple access (with updates to database with ORM tables."""

    def __init__(self,
                 name: str,
                 *classes: Type[DbTable],
                 version: int,
                 on_connect: Optional[Callable[[DbCursor], None]] = None,
                 on_create: Optional[Callable[[DbCursor], None]] = None,
                 ) -> None:
        self.name = name
        self.classes = classes
        self.version = version
        self.on_connect = on_connect
        self.on_create = on_create
        self.lock = Lock()

    def _create_tables(self, cur: DbCursor) -> Optional[int]:
        """Create all missing tables in the DB. Return old version."""
        # Handle DB migration.
        old_ver = update_db_version(cur, self.version)
        cur.create_tables(*self.classes)
        return old_ver

    def _on_connect(self, cur: DbCursor) -> None:
        """Do stuff on connect."""
        old_ver = self._create_tables(cur)
        if old_ver is None and callable(self.on_create):
            self.on_create(cur)
        if callable(self.on_connect):
            self.on_connect(cur)

    @contextmanager
    def cursor(self, *, orm: bool = True) -> Iterator[DbCursor]:
        """Get ORM cursor in `with` statement."""
        with self.lock:
            db = db_manager[self.name]
            with db.cursor(initialize=False) as cur:
                if not db.initialized:
                    self._on_connect(cur)
                    db.initialized = True
                cur.orm = orm
                yield cur
